#+TITLE: Haskell 2025 Course Part 3 - Binary Trees
#+PROPERTY: header-args:haskell :mkdirp yes :padline no :exports code
#+AUTHOR: Aijaz M
#+DATE: <2025-07-11 Fri>
#+FILETAGS: Haskell:OU:PhilM:2025
#+DESCRIPTION: Part 3 of Phil Molyneux's Course on Haskell
#+OPTIONS: toc:nil num:nil creator:nil tags:nil f:nil d:nil \n:t
* Intro
This is the binary trees part of Phil M's Haskell course part 3.
#+begin_src haskell :tangle ./src/HaskellCourse202503BT.hs
module Haskellcourse202503BT where
#+end_src
* Binary Tree
** Here is an ALGEBRAIC data type (ADT) of Binary Trees
*** It's algebraic in the sense that it's created by adding and multiplying together other data types. Adding types means saying that it can have this or that value (emptybt or nodebt) and multiplying means it has to combine multiple values (getdatabt, getleftbt etc)
*** It's worth emphasising that EmptyBT is a value in itself, not a variable that needs a value. NodeBT with the fields filled in would also be a value.
#+begin_src haskell :tangle ./src/HaskellCourse202503BT.hs
  -- -- --
  -- Let's define a binary tree type
  -- -- --
  data TreeBT a = EmptyBT
                | NodeBT {
                    getDataBT  :: a,
                    getLeftBT  :: TreeBT a,
                    getRightBT :: TreeBT a
                }
                deriving (Eq, Read, Show)

  mkEmptyBT :: TreeBT a
  mkEmptyBT = EmptyBT

  mkNodeBT :: a -> TreeBT a -> TreeBT a -> TreeBT a
  mkNodeBT x t1 t2 = NodeBT x t1 t2

  isEmptyBT :: TreeBT a -> Bool
  isEmptyBT EmptyBT                   = True
  isEmptyBT (NodeBT x leftBT rightBT) = False

  heightBT :: TreeBT a -> Int
  heightBT EmptyBT = 0
  heightBT (NodeBT nodeX leftBT rightBT)
                   = 1 + max (heightBT leftBT) (heightBT rightBT)

  sizeBT :: TreeBT a -> Int
  sizeBT EmptyBT                       = 0
  sizeBT (NodeBT nodeX leftBT rightBT) = 1 + sizeBT leftBT + sizeBT rightBT

  exposeBT :: TreeBT a -> (a, TreeBT a, TreeBT a)
  exposeBT EmptyBT                   = error " exposeBT applied to EmptyBT"
  exposeBT (NodeBT a leftBT rightBT) = (a, leftBT, rightBT)
  -- -- --
#+end_src
** Binary Tree examples
#+begin_src haskell :tangle ./src/HaskellCourse202503BT.hs
  -- -- --
  egBSTree :: TreeBT Char
  egBSTree = mkNodeBT 'H'
               (mkNodeBT 'D'
                 (mkNodeBT 'B'
                   (mkNodeBT 'A' mkEmptyBT mkEmptyBT)
                   (mkNodeBT 'C' mkEmptyBT mkEmptyBT))
                 (mkNodeBT 'F'
                   (mkNodeBT 'E' mkEmptyBT mkEmptyBT)
                   (mkNodeBT 'G' mkEmptyBT mkEmptyBT))
               )
               (mkNodeBT 'L'
                 (mkNodeBT 'J'
                   (mkNodeBT 'I' mkEmptyBT mkEmptyBT)
                   (mkNodeBT 'K' mkEmptyBT mkEmptyBT))
                 (mkNodeBT 'N'
                   (mkNodeBT 'M' mkEmptyBT mkEmptyBT)
                   (mkNodeBT 'O' mkEmptyBT mkEmptyBT))
               )
  -- -- --
#+end_src
** Depth-first Traversal
Remember, X-order (where X = pre, in or post) gives the position of VISITING (not traversing) any given root vs its children; it therefore also gives the type of notation created in the resulting list if that list were functions - prefix notation (+ 7 4), infix notation (7 + 4) or postfix notation (7 4 +)
#+begin_src haskell :tangle ./src/HaskellCourse202503BT.hs
  -- -- --
  inOrderBT :: TreeBT a -> [a]
  inOrderBT EmptyBT = []
  inOrderBT (NodeBT nodeX leftBT rightBT)
    = inOrderBT leftBT ++ [nodeX] ++ inOrderBT rightBT

  preOrderBT :: TreeBT a -> [a]
  preOrderBT EmptyBT = []
  preOrderBT (NodeBT nodeX leftBT rightBT)
    = [nodeX] ++ preOrderBT leftBT ++ preOrderBT rightBT


  postOrderBT :: TreeBT a -> [a]
  postOrderBT EmptyBT = []
  postOrderBT (NodeBT nodeX leftBT rightBT)
    = postOrderBT leftBT ++ postOrderBT rightBT ++ [nodeX]
  -- -- --
#+end_src
** Breadth-first Traversal v1
Breadth-first is good for finding shortest-paths (but not for weighted trees) or level-by-level exploration of a structure
We can write a recursive function to return a list of lists, where each inner list is a level of the tree. Let's call it a level order list.
#+begin_src haskell :tangle ./src/HaskellCourse202503BT.hs
  -- -- --
  levelOrderBT :: TreeBT a -> [[a]]
  levelOrderBT EmptyBT = []
  levelOrderBT (NodeBT x leftBT rightBT)
    = [[x]] ++ longZipMerge (levelOrderBT leftBT) (levelOrderBT rightBT)

  longZipMerge :: [[a]] -> [[a]] -> [[a]]
  longZipMerge [] yss = yss
  longZipMerge xss [] = xss
  longZipMerge (xs:xss) (ys:yss)
    = [xs ++ ys] ++ longZipMerge xss yss

  flattenLevels :: [[a]] -> [a]
  flattenLevels levels = [elem | level <- levels, elem <- level]

  breadthBT :: TreeBT a -> [a]
  breadthBT t = (flattenLevels . levelOrderBT) t
  -- -- --
#+end_src
** Breadth-first Traversal v2
The above works but does traverse the entire depth of the left subtree (with respect to every node) first before starting on the right. Very inefficient if we have a big tree. So let's define a function that gets us a particular depth.
#+begin_src haskell :tangle ./src/HaskellCourse202503BT.hs
  labelsAtDepth :: Int -> TreeBT a -> [a]
  labelsAtDepth d EmptyBT = []
  labelsAtDepth d (NodeBT x leftBT rightBT)
    | d == 0    = [x]
    | otherwise = (labelsAtDepth (d-1) leftBT)
               ++ (labelsAtDepth (d-1) rightBT)

#+end_src
So we feed this function a depth and a tree and it'll return everything on that level. Let's use that to traverse the tree level by level.
#+begin_src haskell :tangle ./src/HaskellCourse202503BT.hs
  bfTravByLevel :: TreeBT a -> [a]
  bfTravByLevel t = bfTbyL 0 t
  bfTbyL :: Int -> TreeBT a -> [a]
  bfTbyL d t
    | null xs    = []
    | otherwise  = xs ++ bfTbyL (d+1) t
        where xs = labelsAtDepth d t
  --------
  --------
#+end_src
* Binary Tree Exercises
** Binary Tree Exercises 1
Write a function isLeaf that returns True iff the node has two empty subtrees
#+begin_src haskell :tangle ./src/HaskellCourse202503BT.hs
  isLeaf :: TreeBT a -> Bool
  isLeaf EmptyBT    = False
  isLeaf (NodeBT _ EmptyBT EmptyBT) = True
  isLeaf (NodeBT _ _ _) = False
  --
#+end_src
Write a function numLeaves that returns the number of leaves in a tree
#+begin_src haskell :tangle ./src/HaskellCourse202503BT.hs
  numLeaves :: TreeBT a -> Int
  numLeaves EmptyBT = 0
  numLeaves (NodeBT _ EmptyBT EmptyBT) = 1
  numLeaves (NodeBT _ leftBT rightBT) = numLeaves leftBT + numLeaves rightBT
  --
#+end_src
Write a function numLeavesAtLevel that returns the number of leaves at level d.

I found this to be quite a challenging problem, and I'm not sure my first solution is very elegant. Eventually I found the second way of doing it, but it does involve an as-pattern - is that bad practice? I'd be keen to know if there are better ways of achieving it.
#+begin_src haskell :tangle ./src/HaskellCourse202503BT.hs
  numLeavesAtLevel :: Int -> TreeBT a -> Int
  numLeavesAtLevel target tree = count 0 tree
    where
      count :: Int -> TreeBT a -> Int
      count currentLevel EmptyBT = 0
      count currentLevel (NodeBT x leftBT rightBT)
        | currentLevel == target =
            if isLeaf (NodeBT x leftBT rightBT) then 1 else 0
        | currentLevel < target  =
            count (currentLevel+1) leftBT + count (currentLevel+1) rightBT
        | otherwise              = 0

  numLeavesAtLevel' :: Int -> TreeBT a -> Int
  numLeavesAtLevel' _ EmptyBT = 0
  numLeavesAtLevel' d t@(NodeBT _ leftBT rightBT)
    | d == 0    = if isLeaf t then 1 else 0
    | d > 0     = numLeavesAtLevel' (d-1) leftBT + numLeavesAtLevel' (d-1) rightBT
    | otherwise = 0
#+end_src
Write a function isFull that takes a binary tree and returns True iff the tree is a Full binary tree.
#+begin_src haskell :tangle ./src/HaskellCourse202503BT.hs
  isFull :: TreeBT a -> Bool
  isFull EmptyBT                   = True
  isFull (NodeBT _ leftBT rightBT) =
    case (isEmptyBT leftBT, isEmptyBT rightBT) of
      (True, True)                 -> True
      (False, False)               -> isFull leftBT && isFull rightBT
      _                            -> False

  isFull' :: TreeBT a -> Bool
  isFull' EmptyBT                       = True
  isFull' (NodeBT _ EmptyBT EmptyBT)    = True
  isFull' (NodeBT _ leftBT rightBT)
    | isFull' leftBT && isFull' rightBT = True
    | otherwise                         = False
#+end_src
